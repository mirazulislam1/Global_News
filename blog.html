<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Answer to the quetions</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">
  </head>
  <body class="container">
     <!-- navbar start -->
     <nav class="navbar navbar-expand-lg bg-light p-4">
      <div class="container-fluid">
        <a class="navbar-brand bg-primary text-white px-2 rounded-2" href="#">Global</a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
              <a class="navbar-brand text-primary" href="#">News</a>
          </ul>
          <form class="d-flex" role="search">

              <a class="navbar-brand text-primary" href="index.html">Home</a>
              <a class="navbar-brand" href="#">Blog</a>
              <img src="image/Avatar.png" alt="">
             
          </form>
        </div>
      </div>
    </nav>
    <!-- navbar end -->
    <!-- between var let and const -->
    <section>
        <table class="table caption-top border border-1">
            <h2 class="mb-4">Differences between var, let, and const</h2>
            <thead>
              <tr>
                <th scope="col">No</th>
                <th scope="col">var</th>
                <th scope="col">let</th>
                <th scope="col">const</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <th scope="row">1</th>
                <td>The scope of a var variable is functional scope.</td>
                <td>The scope of a let variable is block scope.</td>
                <td>The scope of a const variable is block scope.</td>
              </tr>
              <tr>
                <th scope="row">2</th>
                <td>It can be declared without initialization.</td>
                <td>It can be declared without initialization.</td>
                <td>It cannot be declared without initialization.</td>
              </tr>
              <tr>
                <th scope="row">3</th>
                <td>It can be accessed without initialization as its default value is “undefined”.</td>
                <td>It cannot be accessed without initialization otherwise it will give ‘referenceError’.</td>
                <td>It cannot be accessed without initialization, as it cannot be declared without initialization.</td>
              </tr>
              <tr>
                <th scope="row">4</th>
                <td>It can be updated and re-declared into the scope.</td>
                <td>It can be updated but cannot be re-declared into the scope.</td>
                <td>It cannot be updated or re-declared into the scope.</td>
              </tr>
            </tbody>
          </table>
    </section>
    <!-- between regular function and arrow funtion -->
    <section>
        <table class="table caption-top border border-1">
            <h2 class="mb-4">between regular function and arrow funtion</h2>
            <thead>
              <tr>
                <th scope="col">NO</th>
                <th scope="col">regular function</th>
                <th scope="col">arrow function</th>
        
              </tr>
            </thead>
            <tbody>
              <tr>
                <th scope="row">1</th>
                <td>Inside of a regular JavaScript function, this value (aka the execution context) is dynamic. <br> const myObject = {
                  method() {
                    console.log(this);
                  }
                };
                myObject.method(); </td>
                <td>The behavior of this inside of an arrow function differs considerably from the regular function's this behavior. The arrow function doesn't define its own execution context. <br> 
                  const myObject = {
                    myMethod(items) {
                      console.log(this);
                      const callback = () => {
                        console.log(this);
                      };
                      items.forEach(callback);
                    }
                  };
                  myObject.myMethod([1, 2, 3]); </td>
                
              </tr>
              <tr>
                <th scope="row">2</th>
                <td>As seen in the previous section, the regular function can easily construct objects.

                  For example, the new Car() function creates instances of a car: <br>
                  function Car(color) {
                    this.color = color;
                  }
                  const redCar = new Car('red');</td>
                <td>A consequence of this resolved lexically is that an arrow function cannot be used as a constructor.

                  If you try to invoke an arrow function prefixed with new keyword, JavaScrip throws an error:
                  <br>
                  const Car = (color) => {
                    this.color = color;
                  };
                  const redCar = new Car('red'); // TypeError: Car is not a constructor</td>
                
              </tr>
              <tr>
                <th scope="row">3</th>
                <td>Inside the body of a regular function, arguments is a special array-like object containing the list of arguments with which the function has been invoked.</td>
                <td>On the other side, no arguments special keyword is defined inside an arrow function.

                  Again (same as with this value), the arguments object is resolved lexically: the arrow function accesses arguments from the outer function.</td>
            
              </tr>
            </tbody>
          </table>
    </section>
    <!-- why we can use template string -->
    <section>
      <h2>why we can use template strings?</h>
       <p class="fs-6 mt-4">
        Template literals are literals delimited with backtick (`) characters, allowing for multi-line strings, for string interpolation with embedded expressions, and for special constructs called tagged templates.
        Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.
        </p>
    </section>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa" crossorigin="anonymous"></script>
  </body>
</html>